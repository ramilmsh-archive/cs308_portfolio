CompSci 308: VOOGASalad Analysis
===================

> This is the link to the assignment: [VOOGASalad](http://www.cs.duke.edu/courses/compsci308/current/assign/04_voogasalad/)


Design Review
=======

### Overall Design

#### Description

* There are few main parts of this project:

  * **Engine**: is a module that maintains all of the game data, manages all of the events, timeline and logic; it renders graphics onto a Camera, which in turn can be used within any legal javafx application. Therefore, engine and player environment communicate with the engine via camera, more specifically, by adding the node created within the camera and adding it to a visualization module. It also would allow to do mini maps, by maintaining only one instance of the engine, and rendering the same contents with different parameters.

  * **Database**: is a module that ensures secure storage of the data files, folders and, above all, JSON objects. I helps us create and save initial game state, which is defined through Authoring, in-game states, that change in realtime, as you play (path to multiplayer). This database allows realtime editing of the game by several users simultaneously. In future, it is supposed to provide a better platform for distributing game files, as well as updates in the future.

  * **Authoring**: is a a piece of software that is intended for game-creation: defining the initial state of the game, levels, entities, logic and actions. It is supposed to allow you add different types ("blueprints") of entities, based on the script combination that they have, as well as creating a fully-custom entity with custom scripts and listeners. In other words, authoring was supposed to be a visual, user-friendly tool to edit the game JSON, so that it can be played in the future.

* The focus of our implementation of the game engine was flexibility and granularity: we would create a game engine and add layers one by one, without tethering the engine code to any specific genre, rather defining it by the set of tools we were going to provide. Our genre was an RPG, therefore, base scripts, such as **_move_**, **_update_\__position_**, **_gravity_**, are designed to be able to handle basic functionality, such as displaying an entity at a certain position and moving it, should the appropriate parameters change. In order to completely change the genre, one would simply have to develop a requisite set of scripts to support it: grid-style movements, sprite change on direction of motion, and tile-based collision detection would be required for a **tile-based** game.

* The game is represented by the set of specifically-formatted JSON files (root.json, images.json, scripts.json), as well as the complimentary files: images and scripts in specified paths. Main data is stored in the root.json, which contains all of the entity information, such as it's properties, listeners and scripts. Due to the tree structure of the game, each entity must also define a list of children (which may be empty), which are its dependent entities. We use this tree structure to split the game into levels: first level - is the global game root, its immediate children - are levels, their children are the actual contents of each of the levels.

#### Analysis

* JSONToObjectConverter.java: I think is a good example of well-structured code, first of all - it is well documented, the class has thorough description, so does every method; the naming conventions are followed well - JSONToObjectConverter class converts JSON to a java object, which is perfectly logical, JSONToObjectConverter::createObjectFromJSON creates object from JSON, provided class and JSON object; this class only does what it has been declared to do, nothing else (Single Responsibility); it is also generic enough to match its purpose - creating any object from JSON data, e.g. it is not locked in for a specific class tailored for our use case, instead it does so for any class of objects, which follow a certain convention, which allows for flexibility and scalability and prevents us from rewriting it in a hypothetical abstract use case.
* EntityManager.java: I think it is a good example of awful "spaghetti-code", which was caused by our desire to avoid rewriting authoring (which turned out was a better idea). First of all, it is situated in Engine, however, it serves primarily authoring purposes, second - the name is too vague to be able to understand what it does exactly; third, the functionality is scattered and incoherent - it deals with root nodes, backgrounds, layers, levels, pubsub, etc., which makes no sense, since each of these functionalities must be split into separate classes; it has many back-door references - ObjectFactory, Camera, gridSize; it is impossible to use, since it is not clear what one must instantiate in order to be able to run the game (it is, in fact, supposed to be used through a panel for some reason); it is poorly documented.
* The lesson here is that one must try and follow SOLID design principles, in order to make the code readable, in particular, single responsibility, as it adds clarity. Every functionality MUST have one and only one access point, it should do exactly what it is supposed to do in full and only what it is supposed to do, otherwise it becomes hard to understand and, therefore, use.

### Your Design

* High-level design
  * Every entity is defined by the set of scripts and listeners that are attached to it. Basic idea is that every entity is "Evented", e.g., it can accept events and act on them. The structure is that the scripts can communicate with each other using those events. Engine emits low-level events, such as TICK and all the input events, but the scripts then can listen to those events and act on them and/or emit new custom events, which can be listened to by another script. This allows us reduce CPU usage significantly, by only executing necessary code, when it needs to be executed, instead of performing all of the calculations on every tick. This would also allow us to avoid unnecessary computations, such as collision checking for objects without position.
* Two features
  * FSM: the idea is to be able to implement Moore's finite-state machine to able to pipeline branching, e.g. game logic, by splitting steps into interdependent states, which have their own properties and actions. For example, a warrior-type character, could be steady, attacking or under attack, so we implement a FSM, which sets appropriate sprites for the character for each of the states and action to display it, deduct health points from self or opponent. Other part of a FSM is transitions, those are simply conditions that determine whether or not a transition from one state to another should be made. For example, if our character is in steady state and detects an enemy nearby, it will want to transition into "attack" state, however, if they have been attacked, you might want to transition to "under attack" state, with second transition taking precedence, in this example. So really, FSM is a collection of States and Transitions. When designing it, the main idea was to provide a utility for the scripts to able to create their own finite state machines. One of the challenging aspects about this is how to define transitions, so that it is easy enough for the user to describe and or can be transpiled from user input into a machine-friendly transition definition. Final choice was a Closure, since it allowed me to simply provide all the necessary data as arguments, however, I have never solved problem of making it user friendly. Ideally, there are no dependencies for an FSM, since it is merely a utility, so that was quite simple.
  * PubSub and Evented: are very similar with a few minor differences, both implement publish/subscribe pattern. The design idea, is that PubSub is a communication link for all of the components within a workspace, while Evented allows to make objects event targets and ad event listeners to specific instances of them, allowing us to perform certain instance-specific actions on events. It has a list of channels and messages/events associated with them. In order to receive a message, one has to subscribe/listen to a channel, providing a callback, which is executed, whenever a message/event is published/emitted. To publish, one must simply create an instance of a message and call PubSub::publish(Channel, Message)/Evented::dispatchEvent(Channel, Event). There are two types of the channels: synchronous and asynchronous. Synchronous channels are blocking channels, meaning that they wait for the callback to be executed and return the results. Asynchronous channels are non-blocking, they are meant for updates, which may happen in multiple places. Those messages are resembling that of Event, e.g. several different agents may choose to "listen" to a channel and react to the message in their own way. There is no expectation of a return value for an asynchronous channel. The challenge was separating components of the program, while maintaining a universal communication protocol; additionally, I needed to modify PubSub, such that it could be used a global communication center, as well as for local communications, which I have solved by making it accept Properties object. One of the assumptions was a certain data type, which I have hidden by introducing generic Message class, which allows you to transmit any kind of data over PubSub at all. In addition, there was a problem with using generic type, caused by ClassCastException, which I have solved by verifying the class before sending the message, so that it is guaranteed that one will only receive correct messages.

### Flexibilty

* Describing final API
  * **Power**: our script-based API is extremely flexible and powerful. It allows the user to do anything they want with the entities we provide, by the way of defining groovy scripts that accept the entity, its properties, bindings and, optionally, event, if it is a listener. The actions can be split into many granular scripts that perform a single task at a time, while having access to raw user inputs and ticks. It is so powerful indeed, that one an create a game of any genre using our engine, without limitations. Entities have group nodes, which can have other nodes added to them, such as circles, images, MediaViews to play sound, etc. One only has to define corresponding properties to the script, e.g., an entity does not necessarily has to have a position at all, or visual representation.
  * **Simplicity**: our API has a heavy skew towards power, which results in simplicity suffering in many ways. The design we were trying to implement could have provided a balance of both, by providing an access to a low level API, as well as a selection of default scripts that would eliminate the need to write any code whatsoever. However, we got caught in our only messy structure and never got around to creating script library, proper entity blueprints, or UI. With a proper UI, one could mask script addition as simple object creation, sound or other user-friendly practices, which would mask existing of the scripts altogether, while simply running them in the background. However, we did not have the time to do that, therefore, our project lacks simplicity, in order to create a game, one would have to almost inescapably write Groovy code, which must be perfectly valid, because otherwise, the engine will simply throw exceptions constantly.
* Describe two features:
  * **The Online Database**: because it is extremely flexible and almost entirely encapsulated, there is no need for anyone to know the implementation, in order to use it, the only requirements are that you extend trackable object and add ```@Expose``` annotation to any instance variable you wish to save and the rest is done for you. This is a very generic feature, it has very lax requirements, meaning that

### Alternate Designs

* We have decided from the beginning that we want to mimic Unity in the way of using scripts to define objects, however, initially, the implementation was very interesting. Entities had a manager for everything, hardcoding some major points of the game, such as representation: every entity was hardcoded to be represented by a single image, from within a class that was called Render, for some reason. The groovy scripts were basically java classes, which did not leverage script nature of groovy at all, by requiring every script to extend GroovyScript class. The position of the objects was kept with transforms, instead of positions. It was quite a difficult to discern architecture and we had no idea on how to move forward with it. After midpoint demo, I have proposed an engine redesign: we would make entity a tree structure, so that we can wrap around JavaFX. The Entities would have children, as well as "representation" - a JavaFX group that would contain necessary javafx data about it, such as ImageView, Shape, MediaView, or a combination of the above. The entities would not be more generic and function of the engine would shift towards managing the scripts that would perform all of the actions, through newly created events, which prevent massive amounts of computation from happening non-stop. However, later on, EntityManager made a reappearance, Entities became more complicated and started to incorporate hitboxes, position, etc, making the structure more messy and complicated. All the scripts would initially be simply scripts that are only executed once, with entity and bindings attached as instance variables. The scripts would then subscribe to the appropriate channels, however, a decision was made to separate scripts from listeners. The listeners would be scripts that would be executed on events, however, this required us to reevaluate groovy code on every step, which harmed performance. That is when we introduced script caching and refactored all scripts to be Closures, so that we can keep them in memory, but only provide the context on execute.

* Two features:
  * One proposal was to remake the authoring to be a game within the engine, so that it would be easier to manage drag and drop and visualization. Furthermore, to separate the initial game state and in-game saves, and structure the games to be a self-contained folder. The idea about refactoring authoring would have made it easier and simpler to work with authoring-engine integration and would help us avoid EntityManager and imageScript, which have complicated the engine structure significantly. It would also allow us to do drag and drop easily, however, we have decided that it would be more demanding in terms of resources to that, than to create a entire structure to work around it, which I opposed to. In my experience, better structure always pays off, which was, unfortunately true this time as well: we have spent exorbitant amount of time trying to debug that workaround to no avail. Mixed game saving led to making it impossible to create JSON files manually, while using our authoring environment remained difficult and provided limited capabilities, which resulted in significant drop of game quality and increase in time required to create a game. I would have preferred to stick to the pure tree structure and remake the authoring, however, I was out ruled at the time.

  * Another design decision was to separate scripts from listeners, so that scripts would be executed once in the beginning, while listeners would be executed on certain events. Original solution, was to subscribe to the events from within the scripts. I personally preferred the original method, since, in my opinion it made the structure simpler and more coherent, while not being too difficult to work with, in my opinion. However, new structure would add a little more clarity to the user experience, where the user would no longer need to bother with assigning listeners from within the scripts. My team has made a decision, however, that we want to prioritize user experience in this case, so I obliged, which ultimate revealed that this structure was, in fact, more elegant and lead us to some remarkable performance improvements and made script creation significantly simpler and more intuitive.

### Conclusions

* The tree structure of the entities is by far the best feature we of our project: it allowed us to efficiently and elegantly manage entities, display levels and move entire structures around by simply moving the parent node. From this experience I have learnt the importance of an appropriate hierarchy, when designing software; it can help simplify the code, make it more coherent, even do some work for you, like, for example, switching levels is now simply a matter of reassigning appropriate Entity to the Camera, which allows to display the current Entity, all of its children and, most importantly, pause execution of the code of entities, which are not relevant at any given time by simply not posting tick event, and being able to resume them from their last position without any problem.
* EntityManager is, in my opinion the worst feature we have in the project. It is NOT fault of the person who has created it, it is simply a workaround, designed to prevent remaking authoring environment. We have sacrificed structure and coherence for ease of implementation, however, it has drastically slowed us down and made it hard to debug and work with. The lesson here is importance of maintaining the structure and coherence, which may take extra time, compared to "cut-corner" solution, but is a worthy investment, as it cuts on the debugging and refactoring time, making it a more predictable quantity. Simpler solution may save time in the short run, but it comes with no guarantee of scalability, flexibility or stability; it is impossible to predict time it will take to debug it and whether or not it will become unsuitable for a future use case, prompting to refactor a fundamental part of the code base.
* Coding perspective:
  * My biggest strength is insight, I can see potential design problems early on and know to fix them, or isolate them, so that if I have to redo something in the future, I would not have to rewrite the entire codebase.
  * Planning is my favorite part of coding/designing, it is the problem-solving stage, which is the most interesting part of programming, which actual coding is more of a technicality. It feels good to come up with an elegant solution, which will make it easy to accomplish task at hand. I spend majority of the time planning out the solution in my head before writing any actual code.
  * I have tried to work on my team work skills, learning to work, communicate and listen to my teammates, explain flaws of proposed solution, if I disagree, propose my own ideas, and respect team's decisions despite that I might not agree with them.

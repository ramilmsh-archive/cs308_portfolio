# CompSci 308: SLogo Analysis

> This is the link to the assignment: [SLogo](http://www.cs.duke.edu/courses/compsci308/current/assign/03_slogo/)
>
> [Code](https://github.com/ramilmsh-archive/cs308_slogo) for the project

## Design Review

### Overall Design

+ Description of the overall design
  + Front end
    + The **Main** class starts creates a Controller, Controller creates View, Interpreter, PubSub and Executor. The design idea is that Main manages the instance of the controller, which inturn creates View, which, in turn manages all of the workspaces. Main is just a starting point of the IDE, other is not much to it.
    + **View** is the class that manages all of the workspaces, creates new ones, destroys the old ones. The design idea is that View class instanciates all of the necessary elements of a workspace on the front end by creating MainUI and backend by calling Controller::createBackEnd(Observer, PubSub). It also manages turtle updates from the executor, to update UI properties of the turtle.
    + **MainUI** represents the actual workspace UI. It creates all of the elements of the UI of the workspace, such as menubar, pane, help windows, etc. It also maintains the UI properties of the turtle.
  + Back end
    + **Controller** is the class that is supposed to manage all of the workspace's properties, states and elements. It instanciates View, Interpreter, Executor and PubSub. The design goal is that controller would serve as a middle ground for internal communication between different components within the workspace. It accepts calls from UI to Interpret certain commands and passes them on to the Interpreter, accepts Execute commands from the Interpreter and passes them on to the Executor and returns the value back to the Interpreter. It also handles any other communication, such as requests to change language, reset environment, load variables, update environment state, etc. It does so, using PubSub.
    + **PubSub** implements publish/subscribe pattern. The design idea, is that PubSub is a communication link for all of the components within a workspace. It has a list of channels and messages associated with them. In order to receive a message, one has to subscribe to a channel, providing a callback, which is executed, whenever a message is published. To publish, one must simply create an instance of a message and call PubSub::publish(Channel, Message). There are two types of the channels: synchronous and asynchronous. Synchronous channels are blocking channels, meaning that they wait for the callback to be executed and return the results. Those are meant for Execute commands, when we expect to receive a return value from the Executor, upon executing a TurtleCommand. Asynchronous channels are non-blocking, they are meant for updates, which may happen in multiple places. Those messages are resembling that of Event, e.g. several different agents may choose to "listen" to a channel and react to the message in their own way. There is no expectation of a return value for an asynchronous channel. Async channels are meant for state updates and Interpret requests, such as VariableUpdate, VariableLoad, etc., as any of this actions do not necessarily yield a result and/or it is not important.
    + **Message** implements a data wrapper, to be transferred over PubSub. The design idea, is that PubSub will serve a sole communication link between arbitrary components of the system, in order to prevent adding obscene number of instance variables to each of the classes and having to change them, every time design changes. Message allows us to wrap the data into classes that all inherent from one class and, therefore, can be transferred conveniently over PubSub. On the receiving end, one simply can cast the message to the desired type and parse data from the "package". Casting errors will not occur, since message will not be published over a certain channel, unless it is an instance of the message type associated with that channel. Therefore, we can easily transfer data from one part of the code to another in a fail-proof way, which also allows us to modify the data we send and communication channels easily.
    + **Executor** is responsible for maintaining the turtles, and turtle properties and states, such as position, orientation, etc. It listens for Execute messages, executes the appropriate commands and returns the return value of the commands after execution.
    + **Interpreter** is responsible for maintaining the Slogo environment, the variable scope and user-defined functions, as well as Interpreting String commands and executing them, either internally, such as Make, MakeUserInstruction or any math-related command, which have no bearing on the rest of the code, or send them to the Exector with Execute message. It listens to Interpret message and interprets the included code.
+ What is needed to add new command:
  + Adding new command is relatively simple. There are currently two command prototypes that do the heavy-lifting: PreDefined and WithCode.
    + **PreDefined** is meant for any operations that are a function or a command, in the sense that they conform to the following syntax: ```<command name> [argument list of default argument length]``` | ```(<command name> [argument list with arbitrary length])```. Each predefined function will parse n (either default or arbitrary, depending on the presence of the parenthesis) of the included arguments, by treating each one of them as an expression, and store them in a protected instance variable. When resolve is called, it will resolve recursively resolve all of the its arguments to a value and return ```PreDefined::evaluate(ArrayList<Value>)```, which can be overridden, should one desire to perform custom processing on this list, otherwise, it will call the default evaluate method. Evaluate will in turn return ```Value PreDefined::apply(Value)```, if there is only one argument, otherwise it will call ```Value PreDefined::apply(Value, Value)``` on the first and second arguments, then same thing on the return value and third, and so on and so forth. Apply will, in turn check if one or both values happen to be a list of values, and, if so, performs ```PreDefined<Input>::apply(Input, Input)``` element-wise, e.g. ```(+ 3 4 5 [3 4 5] 9) -> (+ 7 5 [3 4 5] 9) -> (+ 12 [3 4 5] 9) -> (+ [15 16 17] 9) -> [24 25 26]```. This allows me to perform number of mathematical operations, by simply overriding ```PreDefined<Input>::apply(Input[, Input])```. So, in order to add a function that conforms to Predefined restrictions, one would simply create a new class, that extends PreDefined and override any of the appropriate methods, as they see fit.
    + **WithCode**, on the other hand, is a simple wrapper that simply expects a list of commands after whatever comes before it, good examples are DoTimes and Repeat, which both have a different and custom header syntax, but are followed by the command list.
    + In order to create a fully custom function, the only thing that is required, is to create a class that extends ```abstract class Function```, and implement a constructor ```<Your Function>::new(String, Context)```, that parses all of the necessary elements from ```context.tokenizer``` and stores them as instance variables, which will be called on "compile time"; and ```Value <Your Function>::resolve(Scope scope)```, which will be called on "run time".
  + Final step, is to add this class to appropriate enum within Scope, like so: ```Sum(interpreter.core.include.Sum.class)```.
  + If one means to add a turtle-related command or a query, one must simply add the command name to the appropriate entry to the enum, like so ```Forward(1)``` (argument being default number of arguments) or ```XCoordinate```, respectively. The actual implementation of those would happen in the Executor.
+ The dependencies are mostly clear and easy to find. All the external communication happens over PubSub, while all of the internal component's outer interface, mostly, only includes public methods and parameters. Some of the public methods and parameters, however, are static, but, whenever it is the case, it was conscious choice in favour of resource management, for example, as certain elements cannot be altered on runtime, such as predefined functions, and are global, we can save on runtime and memory usage, by using static variables and methods.
+ Describe two component you did not implement:
  1. **Controller.java**:
      + The code is very confusing and contains a lot of back-references, which makes it very hard to follow and some properties that can be inferred from configuration parameters, either are not, or are decentralized. For example, Controller creates an instance of View, which retains access to the controller, so both have access to each other's properties. In order to create a workspace, which is handled by View, it calls on ```Controller:createBackEnd(Observer, PubSub)```, creates the UI and subscribes to the channels. Also, there is an update method, which deals with very specific command details, down to actually processing the change, moreover, it uses a series of if statements, hard-coding the parameters. It is not very logical to have a class called Controller, which does not perform controlling and class View, which does not only deal with UI, but also taps into model part of MVC, by actually creating the necessary components for data-management. In my opinion, it would have been a better choice to move more functionality into the Controller. In addition, Workspace seems to be a very self-contained element, which would make it more semantically relevant, to have a separate class called Workspace, which would actually initiate all of the necessary components.
      + It is not encapsulated at all, as mentioned previously, the classes cross-reference each other, and most of the parameters are hard-coded, such as the one's in the ```Controller::update(Observable, Object)``` method. On top of that, not all parameters are centralized and inferred from appropriate configuration values. For example, I have tried to change the height of the screen, in order to make some of the examples fit, such as ```flower.logo```, however, upon doing so, I have discovered, that the internal screen limitations for the turtle are not tied to the screen height, but are rather maintained separately, therefore, I have to change code in, at least, two places, before I can change a simple parameter of the simulation.
      + This design follows STUPID design, in many ways, for example, Controller and View are very tightly coupled and call on each other's methods; it has been prematurely optimized: each of the components assumes too much and lacks a degree, or several degrees, of abstraction; the naming is indescriptive, as shown above with the Controller/View pair. I have learnt that each module must be built "in the vacuum", as in without thinking about specific implementation, but rather, given its' name and description, it should be able to deal with all of the possible relevant inputs and provide correct outputs, so that it can be taken from one environment to a completely different one and continue to work. Thinking about design in this way would help, if entire codebase would be refactored, major changes would be applied, while that there would be no need to change that module it in the process, or if we were to change the module itself entirely, while its interactions would remain intact. Also, using TDD (test driven development) may help with this: it allows us to think about what any given class should be able to do, rather than how, making the code testable in the process.
  2. src.executor
      + The code has a consistent naming scheme with relevant class and method names, which generally do what one would expect, based on their name. For example, ```Executor``` deals only with the Execute messages, which it receives, parses the input, while leaving the execution to the relevant classes, and ```Executor::calc(CommandUnit)``` calculates appropriate return values from a command.
      + Each implementation in executor has an interface that specifies its interactions, making it easy to change the implementation, without changing the rest of the project, which is one of the features of SOLID design. For example, to create a pen that alternates colors, instead of being solid, one would simply create a new class that extends Pen and Commandable.
      + Using additional layer of abstraction can help to make the code more flexible, making it conform better to SOLID design style. One way to think about it, is using TDD once again: if you struggle to write a test for a piece of code, you need additional level of abstraction, because most likely, you code is not simple enough yet and incorporates several several functions, instead of serving a singular purpose.
+ No, the code inconsistent in the layout or naming, or descriptiveness. In the interpreter, all of classes and method names use their full unabbreviated names, such as ```Expression, Expression::parse, PreDefined:evaluate```, while executor uses short versions: ```Pen::penVis, Executor::calc``` and the controller is indescriptive, as shown previously. The layout, is mostly consistent, in the sense that four different components of the project are separated and each performs its own part and all of them use the same communication link, however, the internal design is very different, for example, while controller has plenty of hard-coded elements with tight coupling, every element within executor has a dedicated interface.

***

### Your Design

+ High level design of Interpreter:
  + **Interpreter**: is the class that manages the high-level interpreter implementation: it listens to the interpret channel, to parse the String commands, and creates and maintains context. It updates the tokenizer, every time new code is available, parses it and executes, if parsing was successful. This setup can be easily altered for step-by-step execution, since parsing and execution are separated. It is setup this way, for purposes of simplicity, since UI does not support step-by-step execution anyway
  + **util**: util is a package that implements a variety of useful components that simplify parsing and execution
    + **Console**: is a class that helps to generalize and centralize the logging process. The design idea was that all of the output of the interpreter would be passed through the console. If parsing was unsuccessful, Element would be returned as null, but the actual verbose description problem would be printed over console, as well as all of the logs and warnings. The console, in turn, would publish the output to appropriate channel, print it through System.out or System.err, save it in a file, etc.
    + **Context**: is meant as an object that holds pointers to all of the necessary objects, that may be needed in the process of parsing or resolving: translator, console, tokenizer, pubsub, etc. The analogue in other languages would be a dictionary, but java does not have one. It would have been better to make it use getters, instead of instance variable, but it did not seem like a priority at the time.
    + **Scope**: implements a variable and function scope - every variable, constant, command of user-defined function that has been defined. Scope is designed to be recursive, meaning that it is not meant as an object, but rather a tree with a list of children and a parent. By definition, name is accessible, if it is defined in its own scope or any of the parent scopes, but not the children scopes. Every time a variable is set, it overrides the existing value, if it has been previously defined. Elements of the current scope have precedence over elements of the parent scope, therefore, they do not overwrite parent scope's value, merely overshadow it, thus: ```make :a 1 repeat 3 [make :a 5 :a] :a -> <...> 5 5 5 1```.
    + **Tokenizer**: implements preprocessing unit. Design idea, is that it would preprocess the code ina way that it removes all of the irrelevant elements and splits the input into "tokens". Token being defined as a singular, syntactically significant element of the code, for instance:
    ```java
    #bla
    make :a    [3 \t  
    4    (+ 5 4 5)]
    ```
    will be converted into:
    ```java
    make, :a, [, 3, 4, 5, (, +, 5 , 4, 5, ), ]
    ```
    This is done in order to separate parsing from preprocessing and only provide relevant information. Also, once you call ```Tokenizer::next```, the caret has moved, meaning that if you call ```next()``` in one place, and then the other, you will not receive a duplicate, but rather the token at new current position, which is helpful for recursive parsing.
    + **Translator**: implements multilingual support. On creation, it caches all of the languages at the same time, as to optimize for runtime performance. ```Translator::translate(String)```, looks for conversion from input to a standard naming scheme in the current language, and returns it, if it has been found, otherwise, acts as a pass-through for the command (assumes user-defined function).
    ```java
    English: dotimes -> DoTimes (found conversion), foo -> foo (assumes user defined)
    Russian: dotimes -> dotimes (undefined in the current language -> assumes user-defined)
    ```
  + **core**: contains slogo language core elements, everything that is defined within the language: built-in commands, data types, prototypes, etc.
    + **Expression**: a helper-class that creates a data path for the input and channels it to appropriate classes. It takes in the token and determines what the next token is: a Value, Function, List or Variable and triggers corresponding processor. It returns an Element that is result of parsing the tokenizer, leaving it at the end of the previous expression, so that one could call ```Expression::parse``` on the tokenizer repeatedly, until there is no more input. If there has been an error, it will return null:
    ```java
    2 [] [3 define a [:i] define b 5 [a 5]]
    -> Value[2], List[], List[Value[3] Function[a, :i] null 5 List[FunctionCall[a, 5]]]
    ```
    + **elements**: contains possible token types with the means to process them from tokenizer
      + **Element**: prototype of every element that can be obtained by parsing. Must define a toString method for purposes of passing values to the UI, storing and debugging. Must define a resolve method, which returns a Value after execution, since, by definition, everything in logo returns a value.
      + **Function**: prototype for every function we define. Implements few useful methods, such as ```Function::readArguments``` and a function processor for the Expression.
      + **Value**: implements a constant element: anything that is a pure value, without any additional call levels, such as ```"foo, 3.4, 5, true```. Resolves to itself, exit point of recursive resolve method.
      + **List**: implements a value that is a list of Values. May include recursive calls. Compiles to an List of Elements and resolves to ```Value<ArrayList<Value>```, each of which may be either a pure value of a List
      + **Variable**: a symbolic representation of the variable. Resolves to a Value stored in it's scope. If none defined, will return null and output "Variable undefined"
    + **include**: contains all of the implementations of the built-in functions. Refer to JavaDoc comments for more detailed information.
      + **prototypes**: defines prototypes of the built-in elements. Since many of them have similar structure, it is useful to unite them into prototypes
        + **PreDefined**: please, refer to "What is needed to add new command"
        + **WithCode**: please, refer to "What is needed to add new command"
+ High-level design of PubSub:
  + **PubSub**: class that implements publish/subscribe pattern. Please, refer to "Description of the overall design -> Back end -> PubSub"
    + **messages**: contains all the defined messages that can be sent over PubSub
      + **Message**: please, refer to "Description of the overall design -> Back end -> Message"

+ Features:
  + **Element**:
    + As I have mentioned earlier, I parse everything recursively, and get an Element in return, which is, effectively a compiled version of the Expression, I have just processed. The reason, I have implemented the code this way, is because I was faced with a problem: the code can be written recursively: if I parsed a function, it arguments may be functions as well, and so on and so forth. So I realized that any level parsing, is essentially the same, regardless, of the level it self: whether it is the root or if I am already deep in the call stack. Also, I knew that I every expression returns a value, always, which meant that an Element could be resolved always, which provided a nice recursive pattern. All I needed was to define elements, such as Value, List, Function and Variable. And from the Element's interface, which came from assumption that everything returns a value, it followed that I only need to be able to parse and resolve each of those elements, for them to function properly. This made my job a lot easier: suppose I had to parse a function call, all I needed to do, was to get the name of the function and it's inputs, which could be anything, but, by the assumption, were always an Element. Therefore, if I stored my arguments as a List of arguments, all I would need to resolve my function call would be to resolve of the elements in the List to a Value and perform some operation. Therefore, this way I was able to forgo an assumption of arguments being certain type, or having to parse the arguments any differently that any other input. Also, during development, it allowed me to focus on one component at a time, without having to worry about how it will affect any other output, as long as I could resolve it to a Value.
  + **Error reporting**:
    + There is very little to note error reporting integrated into my code at the moment, but the problem is that it is hard coded at the moment, so if I were to add it in the future, I would have to change a lot of code in many different places. I have created two exceptions: InvalidSyntaxError and ValueError, however, I cannot throw them, because I have painted myself into a corner by using ```Function``` interface, which does not support throwing exceptions. Ideally I would like to be able to process the code and either get back a compiled Element or catch a descriptive exception, so I can consistently report it in one place. I have made an assumption that if Element is returned as a null, I has encountered an error, but I would not be able to know what kind of error, which limits my ability for parsing. If I could throw Exceptions, instead of returning null, I would not need to check, whether or not it is null, it would back-propagate instantly, allowing me to automatically and in uniform fashion stop the compilation and to report the error in a centralized manner.

***

### Flexibility

+ The Interpreter is flexible, because it is very simple to add new components, similar to the existing ones, as well as add non-standard features and components, without changing the overall design. For example, the ability to perform vector arithmetics was a last minute decision, but despite being a major change, it did not take much time to implement, thanks to existence of the PreDefined class, which was one of the few changes that I had to make, in order to make it happen. I used the implemented Value.Type class to check, whether a value was a list or not, and simply added the necessary operations to the logic, without touching the interface at all. I believe what makes for a flexible design is a layer of abstraction between each dependency. It insures that when changing the internal implementation, the classes that depend on any given class are untouched (Dependency Inversion Principle). Second, each class should a singular, very specific purpose, which allows to change class implementation dramatically while insuring that the changes you make only affect that one function. It makes it easier to debug, add/remove features, etc., as there is no need to change the interface, therefore, if multiple classes depend on the same class, only relevant ones will be affected (Single Responsibility Principle).
+ Features:
  + **Control Buttons:** This element is interesting, because it is a good example of the flexible code: there is a high-level abstraction: UIComponent, lower-level abstraction: ControlButtonAbstract and finally several implementation: BackwardButton, ForwardButton, etc. Such a structure allows to create custom buttons, whose javafx-related behavior is handled one the higher-level classes, due to the fact that it is a UIComponent, while at the same time, SLogo-related actions are handled in ControlButtonAbstract, making it easy to create new control buttons, by simply specifying the command. Therefore, when creating a new Button there is no need to worry about most details, since they are handled on a higher-level. However, it might be hard to implement a function that makes a 3D polymorphic unicorn prance on the main screen with ControlButtonAbstract, it is relatively simple to do, if we move one level higher - to UIComponent (even though an additional level of abstraction: Button class, would make it even better). This structure also allows us to create nested UIComponents, making it easier to create DOM-like structure for our UI.
  + **StandardTurtle+CommandUnit**: The code only supports the commands have zero, one or two inputs, however, even though most commands accept up to two arguments, some accept multiple, and even if that were not true, there was no guarantee we would not have to deal with those, however, command unit accepts an arbitrary length of inputs, it then proceeds to manipulate the values in a way that defeats the purpose of accepting arbitrary input lengths, by adjusting the value to match input of specific types of commands. This design assumes two-dimensional space and it hard codes values of query, while some mathematical operations are done within StandardTurtle and not TurtlePoint; it also assumes image coordinate plane and inverts y-coordinate and adds the offset inside turtle, instead of having a medium that would deal with compatibility and coordinate transformations. All this makes adding new commands difficult and confusing. It would be hard to add a command that supports multiple inputs, or make turtle work in 3D, as well as trying to animate the turtle, since the execution is hard-coded inside of the executor, it would hard to maintain a separate thread that executes commands in steps.

***

### Alternate Designs

+ The original design has handles extension extremely well, there was not need to make dramatic changes to the code structure, in order to implement them. The only issue was that execution of turtle commands was (and remains) separated from execution of SLogo's internal commands (fd 10 -> turtle, + 10 10 -> SLogo). The decision, initially was to separate the executor and interpreter entirely, so that they would be protected from each other, and Interpreter used to process method, which was would return a list of CommandUnit, however, we soon realized, that it would be impossible for the interpreter to ever parse (+ 10 fd 10), since return value depends on the turtle parameters, inaccessible to the interpreter, which is why we had to start using the PubSub, which allowed us to avoid having to send symbolic functions to the Executor.
+ Two design choices:
  + When we have come across the problem discussed above, there were few options: move turtle to the interpreter, which would defeat purpose of the executor, add ability for the executor to process symbolic calculations, which would defeat purpose of having an interpreter (both decisions would also break Single Purpose Principle, by making one component deal with two unrelated issues), passing executor to the interpreter, which would defeat purpose of separating them in the first place, since now, if executor ever changed, interpreter would have to be changed as well, or add another observer/observable to the equation, together with some new public methods to interface of the Interpreter. Bonus of that approach, beyond that it would solve the problem, was that it also did not require us to break the separation of the two classes and did not require us to implement same functionality in two different parts of the code. However, it would also add additional parameter to Interpreter's constructor, and new methods as well. Problem with that is it would mean that every time we wanted to pass additional information to and from Interpreter, or any other class for that matter, we would have to change the structure of the interpreter. Therefore, we have decided to use publish/subscribe pattern instead and enclose the data we wanted to transfer into messages. I prefer the pubsub method, because it makes communication simpler, by allowing to pass different types of data over one object; it makes adding communication links easier, by introducing channels, so there is no need to change the structure, simply add a channel, create a message, subscribe where it is needed and publish; it allows both synchronous and async communication, meaning that several subscribers can see the change at the same time, while it is still possible to request an execution and get the result back, with blocking.
  + Another design choice was related to the previous one, but was made much earlier in the process, and it was to split the Executor and the Interpreter. This approach has, undoubtedly added clarity to the code structure, as the turtle environment, is essentially separate from the variable scope. This decision has also saved us a lot of time for writing the code and allowed us to split the tasks more effectively, by splitting four tasks among four people. However, another approach was to try and add type definitions into SLogo and store the turtle as an object of inside the language, furthermore, add indexing capabilities to the arrays, so that for multiple turtles, we could simply have an array of turtles and then apply certain actions to them. This approach would take us forever to implement and would go well beyond SLogo, or even Logo for that matter, but it would make the ceiling of capabilities of the language higher. The very same idea could be used to create custom objects and types. This would allow us to add integrity to the language and to the project, by unifying yet another couple of similar purpose components. Which is why I would have preferred it in the real world, however, it would be unrealistic to hope to implement it the scope of our assignment.

### Conclusions

+ The best feature of this design, in my opinion, is the recursive interpretation. It taught me value of generalizing the task as much as it is relevant and trying to create a well-structured hierarchy, which will, inevitably make the code more robust and flexible. When I was able to realize that everything is an expression, and that there are only so many different types of expressions, which may consist of other expressions and that the most basic of them are A Value or a Variable, which every expression will end with, I was able to create a very simple structure that allowed me to implement all of the interpreter-dependent extension with ease. Bottom line: one should look for a natural hierarchy in the data they analyze, instead of trying to cover all the cases.
+ The way Controller and View are intermingled is not the best strategy, in my opinion. It makes the code rigid and, therefore, adding new features painful. In order to avoid that, one should follow the principles of SOLID design. Starting by clearly defining the boundaries of each of the subsystems and their purpose. Only provide necessary details and methods to the outside packages, so that there is no confusion between the functions, better readability, and no way to modify something accidentally. The hierarchy should be such that the methods and properties accumulate on each level, in short, every subclass must conform to all of the requirements of its superclass, otherwise, they should be different classes on the same level, and, to duplicated code, additional level of abstraction is required, so that all of the similarities between the two are covered by their superclass. And, finally, each component must have a clearly defined interface, with which all of the interaction happens, so that one could substitute one implementation for another, while maintaining structural integrity.
+ To be a better programmer:
  + I should start paying more attention to the other teams' discussions, in order to avoid duplicating features.
  + I should stop making an entirely encapsulated implementations, without explaining my team the design decisions I have made, as to allow them to interface with my code more effectively and understand it better.
  + I should keep trying to generalize the code I write, caring more about the structure than the implementation, because even though my code may not produce any usable results for quite a while, better structure pays off in the long run.
